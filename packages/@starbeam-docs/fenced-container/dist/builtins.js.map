{"version":3,"sources":["../src/builtins.ts"],"names":[],"mappings":"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","file":"builtins.js","sourcesContent":["import { parserPlugin } from \"@jsergo/mdit\";\nimport \"@mdit-vue/plugin-sfc\";\nimport parseFence from \"fenceparser\";\nimport { Builtins, Title, UnparsedContent } from \"./define.js\";\nimport { Do, El } from \"./nodes.js\";\nimport type { AttrPart, AttrValue } from \"./tokens.js\";\n\ntype OBJECT = ReturnType<typeof parseFence>;\ntype VALUE = OBJECT[keyof OBJECT];\n\nconst BUILTINS = Builtins.empty()\n  .register(\"info\")\n  .register(\"warning\")\n  .register(\"error\")\n  .register(\"tip\", { defaultTitle: null })\n  .register(\"callout\", { defaultTitle: null })\n  .register(\"ðŸ’¡\", ({ tokens, title, content }) =>\n    tokens.el(\"div\", { class: [\"custom-block\", \"lightbulb\"] }, [title, content])\n  )\n  .register(\"lang-ts\", ({ tokens, content }) =>\n    tokens.el(\"div\", { class: [\"lang-ts\"] }, [content])\n  )\n  .register(\"em\", ({ tokens, title, content }) =>\n    tokens.el(\"blockquote\", { class: \"em\" }, [title ?? \"Key Point\", content])\n  )\n  .register(\"persona\", ({ tokens, title, content }) =>\n    tokens.el(\"aside\", { class: [\"persona\", String(title)] }, [content])\n  )\n  .register(\"details\", ({ title, content, attrs, tokens }) => {\n    return tokens.el(\n      \"details\",\n      {\n        class: [\"custom-block\", \"container\", ...normalizePart(attrs[\"type\"])],\n      },\n      [\n        Do(() => {\n          function titleChild() {\n            switch (attrs[\"type\"]) {\n              case \"deep-dive\":\n                // TODO:: Generalize\n                return [El(\"span\", [\"Deep Dive\"]), title];\n              default:\n                return [title.withDefault(\"Details\")];\n            }\n          }\n\n          console.log(titleChild());\n          return [El(\"summary\", { class: \"custom-block-title\" }, titleChild())];\n        }),\n        content,\n      ]\n    );\n  });\n\nexport const fencedContainerPlugin = parserPlugin({\n  name: \"fenced-container\",\n  before: \"fence\",\n}).block((line, md) => {\n  const matched = line.matchStart(/^(?<ticks>````*)md /);\n\n  if (matched.type === \"error\") {\n    return () => (render) => render.html(md.error(matched.error));\n  } else if (matched.type === \"unmatched\") {\n    return false;\n  }\n\n  const ticks = matched.raw.groups?.[\"ticks\"] as string;\n  const fenceline = line.string();\n  const info = fenceline.slice(matched.fragment.length);\n\n  // split the fenceline into the part before the first space (kind) and the\n  // part after it (params).\n  const [kind, params] = split2(info, \" \");\n\n  if (kind === undefined) {\n    return false;\n  }\n\n  const builtin = BUILTINS.tryGet(kind);\n\n  if (builtin === undefined) {\n    return false;\n  }\n\n  return () => {\n    const fenceContent = line.next?.until(\n      (line) => line.slice()?.trim() === ticks\n    );\n\n    return (render) => {\n      const { title, attrs = {} } = parseTitle(params);\n\n      const rendered = builtin.render({\n        md,\n        kind,\n        title: Title.provided(title),\n        attrs,\n        content: UnparsedContent.of(fenceContent),\n      });\n\n      return render.tokens(rendered);\n    };\n  };\n});\n\nfunction parseTitle(params: string | undefined): {\n  /**\n   * false means \"no title\"\n   * undefined means \"default title\"\n   *\n   * if no title is provided, the value will be undefined\n   */\n  title?: string | false | undefined;\n  attrs?: Record<string, VALUE> | undefined;\n} {\n  if (params === undefined) {\n    return {};\n  }\n\n  const trimmed = params.trim();\n\n  if (trimmed.length === 0) {\n    return {};\n  }\n\n  const quotedString = trimmed.match(/^\\s*\"(.*)\"\\s*$/);\n\n  if (quotedString?.[1]) {\n    return { title: quotedString[1] };\n  }\n\n  if (trimmed.match(/[{=]/)) {\n    const parsed = parseFence(trimmed);\n\n    const title = getTitle(parsed[\"title\"]);\n\n    return { title, attrs: parsed };\n  }\n\n  return { title: trimmed };\n}\n\nfunction getTitle(title: VALUE): string | false | undefined {\n  if (title === undefined) {\n    return undefined;\n  } else if (title === false || title === null) {\n    return false;\n  } else {\n    return String(title);\n  }\n}\n\nfunction split2(\n  string: string,\n  delimiter: string\n): [string, string | undefined] {\n  const index = string.indexOf(delimiter);\n  const p0 = index === -1 ? string : string.substring(0, index);\n  const p1 = index === -1 ? \"\" : string.substring(index + 1);\n\n  return [p0, p1];\n}\n\nfunction normalize(value: VALUE): AttrValue {\n  if (value === null || value === undefined) {\n    return undefined;\n  } else if (Array.isArray(value)) {\n    return value.flatMap(normalizePart);\n  } else if (typeof value === \"object\") {\n    throw Error(`Objects are not currently supported as attr values.`);\n  } else {\n    return normalizePart(value);\n  }\n}\n\nfunction normalizePart(value: VALUE): AttrPart[] {\n  if (value === null || value === undefined) {\n    return [];\n  } else if (Array.isArray(value)) {\n    return value.flatMap(normalizePart).filter(isPresent);\n  } else if (typeof value === \"string\") {\n    return [value];\n  } else if (typeof value === \"number\") {\n    return [String(value)];\n  } else if (typeof value === \"boolean\") {\n    throw Error(`Booleans are not supported as part of an attr array.`);\n  } else {\n    throw Error(\n      `Object are not supported as part of an attr array. You passed ${JSON.stringify(\n        value\n      )}`\n    );\n  }\n}\n\nfunction isPresent<T>(value: T | undefined | null): value is T {\n  return value !== undefined && value !== null;\n}\n"]}