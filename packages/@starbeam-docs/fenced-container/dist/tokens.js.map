{"version":3,"sources":["../src/tokens.ts"],"names":[],"mappings":"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","file":"tokens.js","sourcesContent":["import type { PluginHelper } from \"@jsergo/mdit\";\nimport Token from \"markdown-it/lib/token.js\";\n\nexport type SingleAttrValue = AttrPart | boolean;\nexport type AttrPart = string | number | null | undefined;\nexport type AttrValue = SingleAttrValue | AttrPart[];\n\nexport class Tokens {\n  static empty(md: PluginHelper): Tokens {\n    return new Tokens(md);\n  }\n\n  readonly #md: PluginHelper;\n  readonly #tokens: Token[] = [];\n\n  constructor(md: PluginHelper) {\n    this.#md = md;\n  }\n\n  open(tag: string, attrs: Record<string, AttrValue> | undefined = {}): this {\n    const token = new Token(\"paragraph_open\", tag, 1);\n\n    for (const [key, value] of Object.entries(attrs)) {\n      applyValue(token, key, value);\n    }\n\n    this.#tokens.push(token);\n    return this;\n  }\n\n  el(\n    tag: string,\n    attrs?: Record<string, AttrValue> | Children | undefined,\n    children?: Children\n  ): this {\n    function normalize(): {\n      attrs: Record<string, AttrValue>;\n      children: Children | undefined;\n    } {\n      if (\n        attrs === undefined ||\n        Array.isArray(attrs) ||\n        typeof attrs === \"function\"\n      ) {\n        return { attrs: {}, children: attrs };\n      } else {\n        return { attrs, children };\n      }\n    }\n\n    const { attrs: actualAttrs, children: actualChildren = [] } = normalize();\n\n    const token = new Token(\"paragraph_open\", tag, 1);\n\n    for (const [key, value] of Object.entries(actualAttrs)) {\n      applyValue(token, key, value);\n    }\n\n    if (actualChildren === undefined) {\n      return this;\n    }\n\n    if (Array.isArray(actualChildren)) {\n      this.#tokens.push(token);\n      for (const child of actualChildren) {\n        this.#append(child);\n      }\n    } else if (typeof actualChildren === \"function\") {\n      this.#tokens.push(token);\n      actualChildren(this);\n    }\n\n    this.close(tag);\n    return this;\n  }\n\n  close(tag: string): this {\n    this.#tokens.push(new Token(\"paragraph_close\", tag, -1));\n    return this;\n  }\n\n  append(...content: Child[]): this {\n    for (const child of content) {\n      this.#append(child);\n    }\n    return this;\n  }\n\n  parse(content: string): this {\n    this.#tokens.push(...this.#md.parse(content));\n    return this;\n  }\n\n  if<T>(\n    predicate: T,\n    content: (\n      tokens: Tokens,\n      value: Exclude<T, null | undefined | false | \"\" | 0>\n    ) => Tokens\n  ): this {\n    if (predicate) {\n      content(this, predicate as Exclude<T, null | undefined | false | \"\" | 0>);\n    }\n    return this;\n  }\n\n  #append(child: Child): void {\n    if (child === undefined || child === null) {\n      return;\n    } else if (typeof child === \"string\") {\n      this.#tokens.push(text(child));\n    } else if (\"render\" in child) {\n      child.render(this);\n    } else {\n      this.#tokens.push(child);\n    }\n  }\n\n  get tokens(): Token[] {\n    return this.#tokens;\n  }\n}\n\nexport type Child = LazyChild | Token | string | null | undefined;\nexport type Children = Child[] | ((tokens: Tokens) => Tokens);\n\nexport interface LazyChild {\n  render(tokens: Tokens): Tokens;\n}\n\nexport function text(string: string): Token {\n  const token = new Token(\"text\", \"\", 0);\n  token.content = string;\n  return token;\n}\n\nfunction applyValue(token: Token, name: string, value: AttrValue): void {\n  if (value === undefined || value === false) {\n    return;\n  } else if (Array.isArray(value)) {\n    for (const val of attrListValue(value)) {\n      token.attrJoin(name, val);\n    }\n  } else if (value === true) {\n    token.attrSet(name, \"\");\n  } else {\n    const val = attrPart(value);\n    if (val) {\n      token.attrSet(name, val);\n    }\n  }\n}\n\nfunction attrListValue(value: AttrPart[]) {\n  return value.map(attrPart).filter(isPresent);\n}\n\nfunction attrPart(value: AttrPart): string | undefined {\n  if (value === undefined || value === null) {\n    return undefined;\n  } else if (typeof value === \"number\") {\n    return String(value);\n  } else if (typeof value === \"string\") {\n    return value;\n  } else {\n    throw unreachable(value);\n  }\n}\n\nfunction isPresent<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n\nfunction unreachable(_value: never, message = \"unreachable\") {\n  throw new Error(message);\n}\n"]}