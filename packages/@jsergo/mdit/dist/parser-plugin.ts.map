{"version":3,"sources":["../src/parser-plugin.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,SAEE,cAAc,QAET,aAAa;AAiBpB,OAAO,MAAM;IACX,KAAK,OAAe,EAAmB;QACrC,OAAO;YACL,MAAM;YACN;QACF;IACF;IAEA,QAAyB;QACvB,OAAO;YACL,MAAM;QACR;IACF;IAEA,YAA6B;QAC3B,OAAO;YACL,MAAM;QACR;IACF;AACF,CAAC;AAED,MAAM,SAAS,IAAI;IAGR;AADX,OAAO,MAAM;IAOX,OAAO,OAAe,EAAU;QAC9B,OAAO,sBAAA,IAAI,EAAE,QAAM,MAAM,CAAC;IAC5B;IAEA,MAAM,OAAe,EAAU;QAC7B,OAAO,sBAAA,IAAI,EAAE,QAAM,KAAK,CAAC;IAC3B;IAVA,YAAY,KAAmB,CAAE;QAFjC,6BAAS;;mBAAT,KAAA;;oCAGQ,QAAQ;IAChB;AASF,CAAC;AA2BD,OAAO,SAAS,aACd,aAAsC,EAKtC;QACgB;IAAhB,MAAM,UAAU,CAAA,qBAAA,cAAc,GAAG,cAAjB,gCAAA,qBAAsB,CAAC,MAAQ,GAAI;IAEnD,OAAO;QACL,OAAO,CAAU,SAA6B;YAC5C,OAAO,CAAC,IAAgB,UAAqB;gBAC3C,MAAM,cAAc,IAAI,eAAe,IAAI;gBAE3C,QAAQ,GAAG,CAAC;oBAAE;gBAAO;gBAErB,MAAM,SAA8B,CAClC,OACA,WACA,UACA,SACY;oBACZ,QAAQ,GAAG,CAAC;oBACZ,MAAM,UAAU,YAAY,MAAM,CAAC;oBACnC,MAAM,OAAO,QAAQ,IAAI,CAAC;oBAE1B,QAAQ,GAAG,CAAC;oBAEZ,IAAI,KAAK,WAAW,EAAE;wBACpB,OAAO,KAAK;oBACd,CAAC;oBAED,QAAQ,GAAG,CAAC;oBAEZ,MAAM,UAAU,OACd,MACA,IAAI,aAAa;oBAGnB,QAAQ,GAAG,CAAC,WAAW;oBAEvB,IAAI,CAAC,SAAS;wBACZ,OAAO,KAAK;oBACd,CAAC;oBAED,MAAM,SAAS;oBAEf,IAAI,CAAC,QAAQ;wBACX,OAAO,KAAK;oBACd,CAAC;oBAED,IAAI,QAAQ;wBACV,OAAO,IAAI;oBACb,CAAC;oBAED,MAAM,WAAW,OAAO;oBAExB,OAAQ,SAAS,IAAI;wBACnB,KAAK;4BAAQ;gCACX,MAAM,QAAQ,MAAM,IAAI,CAAC,cAAc,IAAI;gCAC3C,MAAM,OAAO,GAAG,SAAS,OAAO;gCAChC,OAAO,IAAI;4BACb;wBACA,KAAK;4BAAS;gCACZ,OAAO,IAAI;4BACb;wBACA,KAAK;4BAAa;gCAChB,OAAO,KAAK;4BACd;oBACF;gBACF;gBAEA,IAAI,YAAY,eAAe;oBAC7B,MAAM,EAAE,KAAI,EAAE,OAAM,EAAE,GAAG;oBACzB,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,CACnB,QACA,MACA;gBAEJ,OAAO,IAAI,WAAW,eAAe;oBACnC,MAAM,EAAE,KAAI,EAAE,MAAK,EAAE,GAAG;oBACxB,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,MAAM;gBACpC,OAAO,IAAI,aAAa,eAAe;oBACrC,MAAM,EAAE,QAAO,EAAE,GAAG;oBACpB,GAAG,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,SAAS;gBAC7B,OAAO,IAAI,YAAY,eAAe;oBACpC,MAAM,EAAE,QAAQ,KAAI,EAAE,GAAG;oBACzB,GAAG,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM;gBAC5B,CAAC;YACH;QACF;IACF;AACF,CAAC","file":"parser-plugin.ts","sourcesContent":["import type MarkdownIt from \"markdown-it\";\nimport type { PluginWithOptions } from \"markdown-it\";\nimport {\n  MDState,\n  MDStateCreator,\n  type LineState,\n} from \"./state.ts\";\nimport type {\n  RuleBlock,\n  TypedBlockRule,\n  TypedBlockState,\n} from \"./types.ts\";\n\ntype RenderedContent =\n  | {\n      readonly type: \"html\";\n      readonly content: string;\n    }\n  | {\n      readonly type: \"empty\";\n    }\n  | { readonly type: \"reconsume\" };\n\nexport class ReturnRendered {\n  html(content: string): RenderedContent {\n    return {\n      type: \"html\",\n      content,\n    };\n  }\n\n  empty(): RenderedContent {\n    return {\n      type: \"empty\",\n    };\n  }\n\n  reconsume(): RenderedContent {\n    return {\n      type: \"reconsume\",\n    };\n  }\n}\n\nconst RENDER = new ReturnRendered();\n\nexport class PluginHelper<Env = unknown> {\n  readonly #state: MDState<Env>;\n\n  constructor(state: MDState<Env>) {\n    this.#state = state;\n  }\n\n  render(content: string): string {\n    return this.#state.render(content);\n  }\n\n  error(message: string): string {\n    return this.#state.error(message);\n  }\n}\n\nexport type BlockPlugin<Env> = (\n  line: LineState,\n  helper: PluginHelper<Env>\n) => Consume | false | undefined;\nexport type Consume = () => Render | false | undefined;\nexport type Render = (render: ReturnRendered) => RenderedContent;\n\nexport type PluginInsertion =\n  | {\n      readonly name: string;\n      readonly before: string;\n    }\n  | {\n      readonly name: string;\n      readonly after: string;\n    }\n  | {\n      readonly replace: string;\n    }\n  | { readonly append: string };\n\nexport type PluginOptions<Env, WrapperEnv> = {\n  readonly env?: (env: Env) => WrapperEnv;\n} & PluginInsertion;\n\nexport function parserPlugin<Env>(\n  pluginOptions: PluginOptions<any, Env>\n): {\n  block: <Options>(\n    plugin: BlockPlugin<Env>\n  ) => PluginWithOptions<Options>;\n} {\n  const wrapEnv = pluginOptions.env ?? ((env) => env);\n\n  return {\n    block: <Options>(plugin: BlockPlugin<Env>) => {\n      return (md: MarkdownIt, options: Options) => {\n        const createState = new MDStateCreator(md, wrapEnv);\n\n        console.log({ plugin });\n\n        const parser: TypedBlockRule<Env> = (\n          state: TypedBlockState<Env>,\n          startLine,\n          _endLine,\n          silent\n        ): boolean => {\n          console.log(\"running parser\");\n          const mdState = createState.create(state);\n          const line = mdState.line(startLine);\n\n          console.log(\"checking\");\n\n          if (line.isCodeBlock) {\n            return false;\n          }\n\n          console.log(\"running plugin\");\n\n          const consume = plugin(\n            line,\n            new PluginHelper(mdState)\n          );\n\n          console.log(\"consume\", consume);\n\n          if (!consume) {\n            return false;\n          }\n\n          const render = consume();\n\n          if (!render) {\n            return false;\n          }\n\n          if (silent) {\n            return true;\n          }\n\n          const rendered = render(RENDER);\n\n          switch (rendered.type) {\n            case \"html\": {\n              const token = state.push(\"html_block\", \"\", 0);\n              token.content = rendered.content;\n              return true;\n            }\n            case \"empty\": {\n              return true;\n            }\n            case \"reconsume\": {\n              return false;\n            }\n          }\n        };\n\n        if (\"before\" in pluginOptions) {\n          const { name, before } = pluginOptions;\n          md.block.ruler.before(\n            before,\n            name,\n            parser as RuleBlock\n          );\n        } else if (\"after\" in pluginOptions) {\n          const { name, after } = pluginOptions;\n          md.block.ruler.after(after, name, parser as RuleBlock);\n        } else if (\"replace\" in pluginOptions) {\n          const { replace } = pluginOptions;\n          md.block.ruler.at(replace, parser as RuleBlock);\n        } else if (\"append\" in pluginOptions) {\n          const { append: name } = pluginOptions;\n          md.block.ruler.push(name, parser as RuleBlock);\n        }\n      };\n    },\n  };\n}\n"]}