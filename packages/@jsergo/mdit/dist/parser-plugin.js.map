{"version":3,"sources":["../src/parser-plugin.ts"],"names":[],"mappings":"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","file":"parser-plugin.js","sourcesContent":["import type MarkdownIt from \"markdown-it\";\nimport type Token from \"markdown-it/lib/token.js\";\nimport {\n  MDState,\n  MDStateCreator,\n  type LineState,\n} from \"./state.js\";\nimport type {\n  RuleBlock,\n  TypedBlockRule,\n  TypedBlockState,\n} from \"./types.js\";\n\ntype RenderedContent =\n  | {\n      readonly type: \"html\";\n      readonly content: string;\n    }\n  | {\n      readonly type: \"tokens\";\n      readonly content: Token[];\n    }\n  | {\n      readonly type: \"empty\";\n    }\n  | { readonly type: \"reconsume\" };\n\nexport class ReturnRendered {\n  html(content: string): RenderedContent {\n    return {\n      type: \"html\",\n      content,\n    };\n  }\n\n  tokens(tokens: Token[]): RenderedContent {\n    return {\n      type: \"tokens\",\n      content: tokens,\n    };\n  }\n\n  empty(): RenderedContent {\n    return {\n      type: \"empty\",\n    };\n  }\n\n  reconsume(): RenderedContent {\n    return {\n      type: \"reconsume\",\n    };\n  }\n}\n\nconst RENDER = new ReturnRendered();\n\nexport class PluginHelper<Env = unknown> {\n  readonly #state: MDState<Env>;\n\n  constructor(state: MDState<Env>) {\n    this.#state = state;\n  }\n\n  get md(): MarkdownIt {\n    return this.#state.md;\n  }\n\n  get env(): unknown {\n    return this.#state.env;\n  }\n\n  renderHTML(content: string): string {\n    return this.#state.renderHTML(content);\n  }\n\n  parse(content: string): Token[] {\n    return this.#state.parse(content);\n  }\n\n  error(message: string): string {\n    return this.#state.error(message);\n  }\n}\n\nexport type BlockPlugin<Env> = (\n  line: LineState,\n  helper: PluginHelper<Env>\n) => Consume | false | undefined;\nexport type Consume = () => Render | false | undefined;\nexport type Render = (render: ReturnRendered) => RenderedContent;\n\nexport type PluginInsertion =\n  | {\n      readonly name: string;\n      readonly before: string;\n    }\n  | {\n      readonly name: string;\n      readonly after: string;\n    }\n  | {\n      readonly replace: string;\n    }\n  | { readonly append: string };\n\nexport type PluginOptions<Env, WrapperEnv> = {\n  readonly env?: (env: Env) => WrapperEnv;\n} & PluginInsertion;\n\nexport function parserPlugin<Env, T = Env>(\n  pluginOptions: PluginOptions<T, Env>\n): {\n  block: <Options>(\n    plugin: BlockPlugin<Env>\n  ) => MarkdownIt.PluginWithOptions<Options>;\n} {\n  const wrapEnv: (env: T) => Env =\n    pluginOptions.env ?? ((env) => env as unknown as Env);\n\n  return {\n    block: <Options>(plugin: BlockPlugin<Env>) => {\n      return (md: MarkdownIt, _options: Options) => {\n        const createState = new MDStateCreator(md, wrapEnv);\n\n        const parser: TypedBlockRule<T> = (\n          state: TypedBlockState<T>,\n          startLine,\n          _endLine,\n          silent\n        ): boolean => {\n          const mdState = createState.create(state);\n          const line = mdState.line(startLine);\n\n          if (line.isCodeBlock) {\n            return false;\n          }\n\n          const consume = plugin(\n            line,\n            new PluginHelper(mdState)\n          );\n\n          if (!consume) {\n            return false;\n          }\n\n          const render = consume();\n\n          if (!render) {\n            return false;\n          }\n\n          if (silent) {\n            return true;\n          }\n\n          const rendered = render(RENDER);\n\n          switch (rendered.type) {\n            case \"html\": {\n              const token = state.push(\"html_block\", \"\", 0);\n              token.content = rendered.content;\n              return true;\n            }\n            case \"tokens\": {\n              for (const token of rendered.content) {\n                state.tokens.push(token);\n              }\n            }\n            case \"empty\": {\n              return true;\n            }\n            case \"reconsume\": {\n              return false;\n            }\n          }\n        };\n\n        if (\"before\" in pluginOptions) {\n          const { name, before } = pluginOptions;\n          md.block.ruler.before(\n            before,\n            name,\n            parser as RuleBlock\n          );\n        } else if (\"after\" in pluginOptions) {\n          const { name, after } = pluginOptions;\n          md.block.ruler.after(after, name, parser as RuleBlock);\n        } else if (\"replace\" in pluginOptions) {\n          const { replace } = pluginOptions;\n          md.block.ruler.at(replace, parser as RuleBlock);\n        } else if (\"append\" in pluginOptions) {\n          const { append: name } = pluginOptions;\n          md.block.ruler.push(name, parser as RuleBlock);\n        }\n      };\n    },\n  };\n}\n"]}