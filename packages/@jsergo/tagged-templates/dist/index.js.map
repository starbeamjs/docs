{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["export function parse<T>(\n  raw: TemplateStringsArray,\n  ...dynamicItems: T[]\n): Lines<T> {\n  const tokens = tokenize([...raw], dynamicItems);\n\n  const lines: Line<T>[] = [];\n  let buffer: Fragment<T>[] = [];\n\n  for (const token of tokens) {\n    if (token.type === \"newline\") {\n      lines.push(Line.from(buffer));\n      buffer = [];\n    } else {\n      buffer.push(token);\n    }\n  }\n\n  return Lines.of(lines);\n}\n\ntype TemplateFn<I extends (items: Lines<any>) => any> =\n  I extends (items: Lines<infer T>) => infer U\n    ? (items: TemplateStringsArray, ...dynamicItems: T[]) => U\n    : never;\n\ntype StringifyFn<I extends (items: Lines<any>) => any> =\n  I extends (items: Lines<infer T>) => any\n    ? (item: T) => string\n    : never;\n\nexport function parsed<\n  Impl extends (items: Lines<any>) => string\n>(impl: Impl): TemplateFn<Impl>;\nexport function parsed<Impl extends (items: Lines<any>) => any>(\n  impl: Impl,\n  stringify: StringifyFn<Impl>\n): TemplateFn<Impl>;\n\nexport function parsed<Impl extends (items: Lines<any>) => any>(\n  impl: Impl\n): TemplateFn<Impl> {\n  return ((raw, ...dynamicItems) =>\n    impl(parse(raw, ...dynamicItems))) as TemplateFn<Impl>;\n}\n\nexport function tokenize<T>(\n  staticItems: string[],\n  dynamicItems: T[]\n): Tokenized<T>[] {\n  const tokens: Tokenized<T>[] = [];\n\n  staticItems.forEach((staticItem, i) => {\n    tokens.push(...parseStaticItem<T>(staticItem));\n\n    if (dynamicItems.length > i) {\n      const dynamicItem = dynamicItems[i] as T;\n      tokens.push(DynamicToken.of(dynamicItem));\n    }\n  });\n\n  return tokens;\n}\n\nfunction parseStaticItem<T>(\n  staticItem: string\n): TokenizedStatic[] {\n  const tokens: TokenizedStatic[] = [];\n  let nextNewline = staticItem.indexOf(\"\\n\");\n\n  while (nextNewline !== -1) {\n    const next = staticItem.slice(0, nextNewline);\n    staticItem = staticItem.slice(nextNewline + 1);\n\n    if (next !== \"\") {\n      tokens.push(TextToken.of(next));\n    }\n    tokens.push(NEWLINE);\n\n    nextNewline = staticItem.indexOf(\"\\n\");\n  }\n\n  if (staticItem !== \"\") {\n    tokens.push(TextToken.of(staticItem));\n  }\n\n  return tokens;\n}\n\ninterface AbstractToken {\n  readonly type: string;\n  display(stringify: (value: unknown) => string): string;\n}\n\nclass TextToken implements AbstractToken {\n  static of(value: string): TextToken {\n    return new TextToken(value);\n  }\n\n  readonly type = \"text\";\n\n  private constructor(readonly value: string) {\n    if (value === \"\") {\n      throw new Error(\"Text tokens must not be empty\");\n    }\n  }\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return `Text(${JSON.stringify(this.value)})`;\n  }\n\n  slice(\n    from: number,\n    to?: number | undefined\n  ): TextToken | null {\n    const sliced = this.value.slice(from, to);\n\n    if (sliced.length === 0) {\n      return null;\n    } else {\n      return TextToken.of(this.value.slice(from, to));\n    }\n  }\n\n  display() {\n    return this.value;\n  }\n}\n\nclass NewlineToken implements AbstractToken {\n  readonly type = \"newline\";\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return `Newline`;\n  }\n\n  display() {\n    return \"\\n\";\n  }\n}\n\nconst NEWLINE = new NewlineToken();\n\nclass DynamicToken<T> implements AbstractToken {\n  static of<T>(value: T): DynamicToken<T> {\n    return new DynamicToken(value);\n  }\n\n  readonly type = \"dynamic\";\n\n  private constructor(readonly value: T) {}\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.value;\n  }\n\n  display(stringify: (value: T) => string): string {\n    return stringify(this.value);\n  }\n}\n\nexport type ProcessLine<T> = (\n  line: Line<T>\n) => Line<T>[] | undefined;\n\nexport class Lines<T> {\n  static of<T>(lines: Line<T>[]): Lines<T> {\n    return new Lines(lines);\n  }\n\n  readonly #lines: Line<T>[];\n\n  constructor(lines: Line<T>[]) {\n    this.#lines = lines;\n  }\n\n  minIndent(): number {\n    return Math.min(\n      ...this.#lines.map(\n        (line) => line.indent?.indent ?? Infinity\n      )\n    );\n  }\n\n  dedent(indent: number): Lines<T> {\n    return Lines.of(\n      this.#lines.map((line) => line.dedent(indent))\n    );\n  }\n\n  display(stringify: (item: T) => string): string;\n  display(this: Lines<string>): string;\n  display(stringify?: (item: T) => string): string {\n    return this.#lines\n      .map((line) => line.display(stringify as any))\n      .join(\"\\n\");\n  }\n\n  *[Symbol.iterator](): IterableIterator<Line<T>> {\n    for (const line of this.#lines) {\n      yield line;\n    }\n  }\n\n  process(lineno: number, processor: ProcessLine<T>): void {\n    const line = this.#lines[lineno];\n\n    if (!line) {\n      return;\n    }\n\n    const lines = processor(line);\n\n    if (lines) {\n      this.#lines.splice(lineno, 1, ...lines);\n    }\n  }\n\n  processFirst(\n    processor: (line: Line<T>) => Line<T>[] | undefined\n  ): void {\n    this.process(0, processor);\n  }\n\n  processLast(\n    processor: (line: Line<T>) => Line<T>[] | undefined\n  ): void {\n    if (this.#lines.length === 0) {\n      return;\n    }\n\n    this.process(this.#lines.length - 1, processor);\n  }\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.#lines;\n  }\n}\n\nclass IndentToken implements AbstractToken {\n  static of(indent: number): IndentToken {\n    return new IndentToken(indent);\n  }\n\n  readonly type = \"indent\";\n\n  constructor(readonly indent: number) {\n    if (indent === 0) {\n      throw new Error(\"Indent tokens must not be zero\");\n    }\n  }\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return `Indent(${this.indent})`;\n  }\n\n  display(): string {\n    return \" \".repeat(this.indent);\n  }\n\n  dedent(indent: number): IndentToken | null {\n    if (this.indent - indent <= 0) {\n      return null;\n    } else {\n      return IndentToken.of(this.indent - indent);\n    }\n  }\n}\n\nclass Line<T> {\n  static from<T>(fragments: readonly Fragment<T>[]): Line<T> {\n    const [first, ...rest] = fragments;\n\n    if (first?.type === \"text\") {\n      const indent = first.value.match(/^\\s*/)?.[0].length ?? 0;\n      const textToken = first.slice(indent);\n\n      const tokens: LineTokens<T> = [\n        IndentToken.of(indent),\n        ...(textToken ? [textToken] : []),\n        ...rest,\n      ];\n\n      return new Line(tokens);\n    } else {\n      return new Line(fragments as LineTokens<T>);\n    }\n  }\n\n  private constructor(readonly tokens: LineTokens<T>) {}\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.tokens;\n  }\n\n  isEmpty(): boolean {\n    return this.tokens.length === 0;\n  }\n\n  get indent(): IndentToken | null {\n    const [first] = this.tokens;\n    if (first?.type === \"indent\") {\n      return first;\n    } else {\n      return null;\n    }\n  }\n\n  dedent(indent: number): Line<T> {\n    if (this.tokens.length === 0) {\n      return this;\n    }\n\n    const [first, ...rest] = this.tokens as [\n      IndentToken | Fragment<T>,\n      ...Fragment<T>[]\n    ];\n\n    if (first.type !== \"indent\") {\n      return this;\n    }\n\n    const dedented = first.dedent(indent);\n\n    if (dedented) {\n      return new Line([dedented, ...rest]);\n    } else {\n      return new Line(rest as LineTokens<T>);\n    }\n  }\n\n  display(stringify: (item: T) => string): string;\n  display(this: Line<string>): string;\n  display(stringify: (item: T) => string = String): string {\n    return this.tokens\n      .map((token) => token.display(stringify as any))\n      .join(\"\");\n  }\n}\n\ntype TokenizedStatic = TextToken | NewlineToken;\ntype Tokenized<T> = TokenizedStatic | DynamicToken<T>;\ntype Token<T> =\n  | IndentToken\n  | TextToken\n  | NewlineToken\n  | DynamicToken<T>;\n\ntype Fragment<T> = TextToken | DynamicToken<T>;\ntype LineTokens<T> = Token<T>[] &\n  (\n    | readonly [IndentToken?, ...Fragment<T>[]]\n    | readonly Fragment<T>[]\n  );\n"]}