{"version":3,"sources":["../index.ts"],"sourcesContent":["export function parse<T>(\n  raw: TemplateStringsArray,\n  ...dynamicItems: T[]\n): Lines<T> {\n  const tokens = tokenize([...raw], dynamicItems);\n\n  const lines: Line<T>[] = [];\n  let buffer: Fragment<T>[] = [];\n\n  for (const token of tokens) {\n    if (token.type === \"newline\") {\n      lines.push(Line.from(buffer));\n      buffer = [];\n    } else {\n      buffer.push(token);\n    }\n  }\n\n  return Lines.of(lines);\n}\n\ntype TemplateFn<I extends (items: Lines<any>) => any> =\n  I extends (items: Lines<infer T>) => infer U\n    ? (items: TemplateStringsArray, ...dynamicItems: T[]) => U\n    : never;\n\ntype StringifyFn<I extends (items: Lines<any>) => any> =\n  I extends (items: Lines<infer T>) => any\n    ? (item: T) => string\n    : never;\n\nexport function parsed<\n  Impl extends (items: Lines<any>) => string\n>(impl: Impl): TemplateFn<Impl>;\nexport function parsed<Impl extends (items: Lines<any>) => any>(\n  impl: Impl,\n  stringify: StringifyFn<Impl>\n): TemplateFn<Impl>;\n\nexport function parsed<Impl extends (items: Lines<any>) => any>(\n  impl: Impl\n): TemplateFn<Impl> {\n  return ((raw, ...dynamicItems) =>\n    impl(parse(raw, ...dynamicItems))) as TemplateFn<Impl>;\n}\n\nexport function tokenize<T>(\n  staticItems: string[],\n  dynamicItems: T[]\n): Tokenized<T>[] {\n  const tokens: Tokenized<T>[] = [];\n\n  staticItems.forEach((staticItem, i) => {\n    tokens.push(...parseStaticItem<T>(staticItem));\n\n    if (dynamicItems.length > i) {\n      const dynamicItem = dynamicItems[i] as T;\n      tokens.push(DynamicToken.of(dynamicItem));\n    }\n  });\n\n  return tokens;\n}\n\nfunction parseStaticItem<T>(\n  staticItem: string\n): TokenizedStatic[] {\n  const tokens: TokenizedStatic[] = [];\n  let nextNewline = staticItem.indexOf(\"\\n\");\n\n  while (nextNewline !== -1) {\n    const next = staticItem.slice(0, nextNewline);\n    staticItem = staticItem.slice(nextNewline + 1);\n\n    if (next !== \"\") {\n      tokens.push(TextToken.of(next));\n    }\n    tokens.push(NEWLINE);\n\n    nextNewline = staticItem.indexOf(\"\\n\");\n  }\n\n  if (staticItem !== \"\") {\n    tokens.push(TextToken.of(staticItem));\n  }\n\n  return tokens;\n}\n\ninterface AbstractToken {\n  readonly type: string;\n  display(stringify: (value: unknown) => string): string;\n}\n\nclass TextToken implements AbstractToken {\n  static of(value: string): TextToken {\n    return new TextToken(value);\n  }\n\n  readonly type = \"text\";\n\n  private constructor(readonly value: string) {\n    if (value === \"\") {\n      throw new Error(\"Text tokens must not be empty\");\n    }\n  }\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return `Text(${JSON.stringify(this.value)})`;\n  }\n\n  slice(\n    from: number,\n    to?: number | undefined\n  ): TextToken | null {\n    const sliced = this.value.slice(from, to);\n\n    if (sliced.length === 0) {\n      return null;\n    } else {\n      return TextToken.of(this.value.slice(from, to));\n    }\n  }\n\n  display() {\n    return this.value;\n  }\n}\n\nclass NewlineToken implements AbstractToken {\n  readonly type = \"newline\";\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return `Newline`;\n  }\n\n  display() {\n    return \"\\n\";\n  }\n}\n\nconst NEWLINE = new NewlineToken();\n\nclass DynamicToken<T> implements AbstractToken {\n  static of<T>(value: T): DynamicToken<T> {\n    return new DynamicToken(value);\n  }\n\n  readonly type = \"dynamic\";\n\n  private constructor(readonly value: T) {}\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.value;\n  }\n\n  display(stringify: (value: T) => string): string {\n    return stringify(this.value);\n  }\n}\n\nexport type ProcessLine<T> = (\n  line: Line<T>\n) => Line<T>[] | undefined;\n\nexport class Lines<T> {\n  static of<T>(lines: Line<T>[]): Lines<T> {\n    return new Lines(lines);\n  }\n\n  readonly #lines: Line<T>[];\n\n  constructor(lines: Line<T>[]) {\n    this.#lines = lines;\n  }\n\n  minIndent(): number {\n    return Math.min(\n      ...this.#lines.map(\n        (line) => line.indent?.indent ?? Infinity\n      )\n    );\n  }\n\n  dedent(indent: number): Lines<T> {\n    return Lines.of(\n      this.#lines.map((line) => line.dedent(indent))\n    );\n  }\n\n  display(stringify: (item: T) => string): string;\n  display(this: Lines<string>): string;\n  display(stringify?: (item: T) => string): string {\n    return this.#lines\n      .map((line) => line.display(stringify as any))\n      .join(\"\\n\");\n  }\n\n  *[Symbol.iterator](): IterableIterator<Line<T>> {\n    for (const line of this.#lines) {\n      yield line;\n    }\n  }\n\n  process(lineno: number, processor: ProcessLine<T>): void {\n    const line = this.#lines[lineno];\n\n    if (!line) {\n      return;\n    }\n\n    const lines = processor(line);\n\n    if (lines) {\n      this.#lines.splice(lineno, 1, ...lines);\n    }\n  }\n\n  processFirst(\n    processor: (line: Line<T>) => Line<T>[] | undefined\n  ): void {\n    this.process(0, processor);\n  }\n\n  processLast(\n    processor: (line: Line<T>) => Line<T>[] | undefined\n  ): void {\n    if (this.#lines.length === 0) {\n      return;\n    }\n\n    this.process(this.#lines.length - 1, processor);\n  }\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.#lines;\n  }\n}\n\nclass IndentToken implements AbstractToken {\n  static of(indent: number): IndentToken {\n    return new IndentToken(indent);\n  }\n\n  readonly type = \"indent\";\n\n  constructor(readonly indent: number) {\n    if (indent === 0) {\n      throw new Error(\"Indent tokens must not be zero\");\n    }\n  }\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return `Indent(${this.indent})`;\n  }\n\n  display(): string {\n    return \" \".repeat(this.indent);\n  }\n\n  dedent(indent: number): IndentToken | null {\n    if (this.indent - indent <= 0) {\n      return null;\n    } else {\n      return IndentToken.of(this.indent - indent);\n    }\n  }\n}\n\nclass Line<T> {\n  static from<T>(fragments: readonly Fragment<T>[]): Line<T> {\n    const [first, ...rest] = fragments;\n\n    if (first?.type === \"text\") {\n      const indent = first.value.match(/^\\s*/)?.[0].length ?? 0;\n      const textToken = first.slice(indent);\n\n      const tokens: LineTokens<T> = [\n        IndentToken.of(indent),\n        ...(textToken ? [textToken] : []),\n        ...rest,\n      ];\n\n      return new Line(tokens);\n    } else {\n      return new Line(fragments as LineTokens<T>);\n    }\n  }\n\n  private constructor(readonly tokens: LineTokens<T>) {}\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.tokens;\n  }\n\n  isEmpty(): boolean {\n    return this.tokens.length === 0;\n  }\n\n  get indent(): IndentToken | null {\n    const [first] = this.tokens;\n    if (first?.type === \"indent\") {\n      return first;\n    } else {\n      return null;\n    }\n  }\n\n  dedent(indent: number): Line<T> {\n    if (this.tokens.length === 0) {\n      return this;\n    }\n\n    const [first, ...rest] = this.tokens as [\n      IndentToken | Fragment<T>,\n      ...Fragment<T>[]\n    ];\n\n    if (first.type !== \"indent\") {\n      return this;\n    }\n\n    const dedented = first.dedent(indent);\n\n    if (dedented) {\n      return new Line([dedented, ...rest]);\n    } else {\n      return new Line(rest as LineTokens<T>);\n    }\n  }\n\n  display(stringify: (item: T) => string): string;\n  display(this: Line<string>): string;\n  display(stringify: (item: T) => string = String): string {\n    return this.tokens\n      .map((token) => token.display(stringify as any))\n      .join(\"\");\n  }\n}\n\ntype TokenizedStatic = TextToken | NewlineToken;\ntype Tokenized<T> = TokenizedStatic | DynamicToken<T>;\ntype Token<T> =\n  | IndentToken\n  | TextToken\n  | NewlineToken\n  | DynamicToken<T>;\n\ntype Fragment<T> = TextToken | DynamicToken<T>;\ntype LineTokens<T> = Token<T>[] &\n  (\n    | readonly [IndentToken?, ...Fragment<T>[]]\n    | readonly Fragment<T>[]\n  );\n"],"names":["parse","raw","dynamicItems","tokens","tokenize","lines","buffer","token","type","push","Line","from","Lines","of","parsed","impl","staticItems","forEach","staticItem","i","parseStaticItem","length","dynamicItem","DynamicToken","nextNewline","indexOf","next","slice","TextToken","NEWLINE","value","Error","Symbol","for","JSON","stringify","to","sliced","display","NewlineToken","constructor","minIndent","Math","min","map","line","indent","Infinity","dedent","join","iterator","process","lineno","processor","splice","processFirst","processLast","IndentToken","repeat","fragments","first","rest","match","textToken","isEmpty","dedented","String"],"mappings":"AAAA,OAAO,SAASA,MACdC,GAAyB,EACzB,GAAGC,YAAiB,EACV;IACV,MAAMC,SAASC,SAAS;WAAIH;KAAI,EAAEC;IAElC,MAAMG,QAAmB,EAAE;IAC3B,IAAIC,SAAwB,EAAE;IAE9B,KAAK,MAAMC,SAASJ,OAAQ;QAC1B,IAAII,MAAMC,IAAI,KAAK,WAAW;YAC5BH,MAAMI,IAAI,CAACC,KAAKC,IAAI,CAACL;YACrBA,SAAS,EAAE;QACb,OAAO;YACLA,OAAOG,IAAI,CAACF;QACd,CAAC;IACH;IAEA,OAAOK,MAAMC,EAAE,CAACR;AAClB,CAAC;AAoBD,OAAO,SAASS,OACdC,IAAU,EACQ;IAClB,OAAQ,CAACd,KAAK,GAAGC,eACfa,KAAKf,MAAMC,QAAQC;AACvB,CAAC;AAED,OAAO,SAASE,SACdY,WAAqB,EACrBd,YAAiB,EACD;IAChB,MAAMC,SAAyB,EAAE;IAEjCa,YAAYC,OAAO,CAAC,CAACC,YAAYC,IAAM;QACrChB,OAAOM,IAAI,IAAIW,gBAAmBF;QAElC,IAAIhB,aAAamB,MAAM,GAAGF,GAAG;YAC3B,MAAMG,cAAcpB,YAAY,CAACiB,EAAE;YACnChB,OAAOM,IAAI,CAACc,aAAaV,EAAE,CAACS;QAC9B,CAAC;IACH;IAEA,OAAOnB;AACT,CAAC;AAED,SAASiB,gBACPF,UAAkB,EACC;IACnB,MAAMf,SAA4B,EAAE;IACpC,IAAIqB,cAAcN,WAAWO,OAAO,CAAC;IAErC,MAAOD,gBAAgB,CAAC,EAAG;QACzB,MAAME,OAAOR,WAAWS,KAAK,CAAC,GAAGH;QACjCN,aAAaA,WAAWS,KAAK,CAACH,cAAc;QAE5C,IAAIE,SAAS,IAAI;YACfvB,OAAOM,IAAI,CAACmB,UAAUf,EAAE,CAACa;QAC3B,CAAC;QACDvB,OAAOM,IAAI,CAACoB;QAEZL,cAAcN,WAAWO,OAAO,CAAC;IACnC;IAEA,IAAIP,eAAe,IAAI;QACrBf,OAAOM,IAAI,CAACmB,UAAUf,EAAE,CAACK;IAC3B,CAAC;IAED,OAAOf;AACT;AAOA,IAAA,AAAMyB,YAAN,MAAMA;IACJ,OAAOf,GAAGiB,KAAa,EAAa;QAClC,OAAO,IAAIF,UAAUE;IACvB;IAIA,YAA6BA,MAAe;qBAAfA;aAFpBtB,OAAO;QAGd,IAAIsB,UAAU,IAAI;YAChB,MAAM,IAAIC,MAAM,iCAAiC;QACnD,CAAC;IACH;IAEA,CAACC,OAAOC,GAAG,CAAC,8BAA8B,GAAG;QAC3C,OAAO,CAAC,KAAK,EAAEC,KAAKC,SAAS,CAAC,IAAI,CAACL,KAAK,EAAE,CAAC,CAAC;IAC9C;IAEAH,MACEhB,IAAY,EACZyB,EAAuB,EACL;QAClB,MAAMC,SAAS,IAAI,CAACP,KAAK,CAACH,KAAK,CAAChB,MAAMyB;QAEtC,IAAIC,OAAOhB,MAAM,KAAK,GAAG;YACvB,OAAO,IAAI;QACb,OAAO;YACL,OAAOO,UAAUf,EAAE,CAAC,IAAI,CAACiB,KAAK,CAACH,KAAK,CAAChB,MAAMyB;QAC7C,CAAC;IACH;IAEAE,UAAU;QACR,OAAO,IAAI,CAACR,KAAK;IACnB;AACF;AAEA,IAAA,AAAMS,eAAN,MAAMA;IACK/B,OAAO,UAAU;IAE1B,CAACwB,OAAOC,GAAG,CAAC,8BAA8B,GAAG;QAC3C,OAAO,CAAC,OAAO,CAAC;IAClB;IAEAK,UAAU;QACR,OAAO;IACT;AACF;AAEA,MAAMT,UAAU,IAAIU;AAEpB,IAAA,AAAMhB,eAAN,MAAMA;IACJ,OAAOV,GAAMiB,KAAQ,EAAmB;QACtC,OAAO,IAAIP,aAAaO;IAC1B;IAIA,YAA6BA,MAAU;qBAAVA;aAFpBtB,OAAO;IAEwB;IAExC,CAACwB,OAAOC,GAAG,CAAC,8BAA8B,GAAG;QAC3C,OAAO,IAAI,CAACH,KAAK;IACnB;IAEAQ,QAAQH,SAA+B,EAAU;QAC/C,OAAOA,UAAU,IAAI,CAACL,KAAK;IAC7B;AACF;AAMA,OAAO,MAAMlB;IACX,OAAOC,GAAMR,KAAgB,EAAY;QACvC,OAAO,IAAIO,MAAMP;IACnB;IAES,CAACA,KAAK,CAAY;IAE3BmC,YAAYnC,KAAgB,CAAE;QAC5B,IAAI,CAAC,CAACA,KAAK,GAAGA;IAChB;IAEAoC,YAAoB;QAClB,OAAOC,KAAKC,GAAG,IACV,IAAI,CAAC,CAACtC,KAAK,CAACuC,GAAG,CAChB,CAACC,OAASA,KAAKC,MAAM,EAAEA,UAAUC;IAGvC;IAEAC,OAAOF,MAAc,EAAY;QAC/B,OAAOlC,MAAMC,EAAE,CACb,IAAI,CAAC,CAACR,KAAK,CAACuC,GAAG,CAAC,CAACC,OAASA,KAAKG,MAAM,CAACF;IAE1C;IAIAR,QAAQH,SAA+B,EAAU;QAC/C,OAAO,IAAI,CAAC,CAAC9B,KAAK,CACfuC,GAAG,CAAC,CAACC,OAASA,KAAKP,OAAO,CAACH,YAC3Bc,IAAI,CAAC;IACV;IAEA,CAAC,CAACjB,OAAOkB,QAAQ,CAAC,GAA8B;QAC9C,KAAK,MAAML,QAAQ,IAAI,CAAC,CAACxC,KAAK,CAAE;YAC9B,MAAMwC;QACR;IACF;IAEAM,QAAQC,MAAc,EAAEC,SAAyB,EAAQ;QACvD,MAAMR,OAAO,IAAI,CAAC,CAACxC,KAAK,CAAC+C,OAAO;QAEhC,IAAI,CAACP,MAAM;YACT;QACF,CAAC;QAED,MAAMxC,QAAQgD,UAAUR;QAExB,IAAIxC,OAAO;YACT,IAAI,CAAC,CAACA,KAAK,CAACiD,MAAM,CAACF,QAAQ,MAAM/C;QACnC,CAAC;IACH;IAEAkD,aACEF,SAAmD,EAC7C;QACN,IAAI,CAACF,OAAO,CAAC,GAAGE;IAClB;IAEAG,YACEH,SAAmD,EAC7C;QACN,IAAI,IAAI,CAAC,CAAChD,KAAK,CAACgB,MAAM,KAAK,GAAG;YAC5B;QACF,CAAC;QAED,IAAI,CAAC8B,OAAO,CAAC,IAAI,CAAC,CAAC9C,KAAK,CAACgB,MAAM,GAAG,GAAGgC;IACvC;IAEA,CAACrB,OAAOC,GAAG,CAAC,8BAA8B,GAAG;QAC3C,OAAO,IAAI,CAAC,CAAC5B,KAAK;IACpB;AACF,CAAC;AAED,IAAA,AAAMoD,cAAN,MAAMA;IACJ,OAAO5C,GAAGiC,MAAc,EAAe;QACrC,OAAO,IAAIW,YAAYX;IACzB;IAIAN,YAAqBM,OAAgB;sBAAhBA;aAFZtC,OAAO;QAGd,IAAIsC,WAAW,GAAG;YAChB,MAAM,IAAIf,MAAM,kCAAkC;QACpD,CAAC;IACH;IAEA,CAACC,OAAOC,GAAG,CAAC,8BAA8B,GAAG;QAC3C,OAAO,CAAC,OAAO,EAAE,IAAI,CAACa,MAAM,CAAC,CAAC,CAAC;IACjC;IAEAR,UAAkB;QAChB,OAAO,IAAIoB,MAAM,CAAC,IAAI,CAACZ,MAAM;IAC/B;IAEAE,OAAOF,MAAc,EAAsB;QACzC,IAAI,IAAI,CAACA,MAAM,GAAGA,UAAU,GAAG;YAC7B,OAAO,IAAI;QACb,OAAO;YACL,OAAOW,YAAY5C,EAAE,CAAC,IAAI,CAACiC,MAAM,GAAGA;QACtC,CAAC;IACH;AACF;AAEA,IAAA,AAAMpC,OAAN,MAAMA;IACJ,OAAOC,KAAQgD,SAAiC,EAAW;QACzD,MAAM,CAACC,OAAO,GAAGC,KAAK,GAAGF;QAEzB,IAAIC,OAAOpD,SAAS,QAAQ;YAC1B,MAAMsC,SAASc,MAAM9B,KAAK,CAACgC,KAAK,CAAC,SAAS,CAAC,EAAE,CAACzC,MAAM,IAAI;YACxD,MAAM0C,YAAYH,MAAMjC,KAAK,CAACmB;YAE9B,MAAM3C,SAAwB;gBAC5BsD,YAAY5C,EAAE,CAACiC;mBACXiB,YAAY;oBAACA;iBAAU,GAAG,EAAE;mBAC7BF;aACJ;YAED,OAAO,IAAInD,KAAKP;QAClB,OAAO;YACL,OAAO,IAAIO,KAAKiD;QAClB,CAAC;IACH;IAEA,YAA6BxD,OAAuB;sBAAvBA;IAAwB;IAErD,CAAC6B,OAAOC,GAAG,CAAC,8BAA8B,GAAG;QAC3C,OAAO,IAAI,CAAC9B,MAAM;IACpB;IAEA6D,UAAmB;QACjB,OAAO,IAAI,CAAC7D,MAAM,CAACkB,MAAM,KAAK;IAChC;IAEA,IAAIyB,SAA6B;QAC/B,MAAM,CAACc,MAAM,GAAG,IAAI,CAACzD,MAAM;QAC3B,IAAIyD,OAAOpD,SAAS,UAAU;YAC5B,OAAOoD;QACT,OAAO;YACL,OAAO,IAAI;QACb,CAAC;IACH;IAEAZ,OAAOF,MAAc,EAAW;QAC9B,IAAI,IAAI,CAAC3C,MAAM,CAACkB,MAAM,KAAK,GAAG;YAC5B,OAAO,IAAI;QACb,CAAC;QAED,MAAM,CAACuC,OAAO,GAAGC,KAAK,GAAG,IAAI,CAAC1D,MAAM;QAKpC,IAAIyD,MAAMpD,IAAI,KAAK,UAAU;YAC3B,OAAO,IAAI;QACb,CAAC;QAED,MAAMyD,WAAWL,MAAMZ,MAAM,CAACF;QAE9B,IAAImB,UAAU;YACZ,OAAO,IAAIvD,KAAK;gBAACuD;mBAAaJ;aAAK;QACrC,OAAO;YACL,OAAO,IAAInD,KAAKmD;QAClB,CAAC;IACH;IAIAvB,QAAQH,YAAiC+B,MAAM,EAAU;QACvD,OAAO,IAAI,CAAC/D,MAAM,CACfyC,GAAG,CAAC,CAACrC,QAAUA,MAAM+B,OAAO,CAACH,YAC7Bc,IAAI,CAAC;IACV;AACF"}